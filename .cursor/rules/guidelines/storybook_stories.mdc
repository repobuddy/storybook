---
description: create or update storybook stories
globs:
alwaysApply: false
---
# Writing Storybook Stories

This document outlines the standards and best practices for creating Storybook stories in our project. It complements the [React Component Specification](mdc:.cursor/rules/commands/react_component_spec.mdc) and [React Component PRD](mdc:.cursor/rules/commands/react_component_prd.mdc) guidelines.

## Quick Start Guide

### üöÄ Essential Rules

1. **File naming**: Use `.stories.tsx` extension, co-locate with source files
2. **Import patterns**: Import from main exports (`../index.js`) and types from `#repobuddy/storybook/internal`
3. **Story structure**: Use CSF format with TypeScript and proper meta configuration
4. **Naming conventions**: Use `BasicUsage` for default stories, descriptive names for variants
5. **Tagging**: Use appropriate tags for organization (`['autodocs']`, `['new']`, etc.)
6. **Documentation**: Use `defineDocsParam` for component and story descriptions

## Basic Story Structure

Use the new Component Story Format (CSF) with TypeScript:

```tsx
import type { Meta, StoryObj } from '#repobuddy/storybook/internal'
import { YourComponent } from './your_component.js'

const meta = {
	title: 'components/YourComponent',
	tags: ['new', 'version:1.0', 'autodocs'],
	component: YourComponent,
	parameters: {
		layout: 'centered',
	},
	argTypes: {
		// Define controls for your props
	},
} satisfies Meta<typeof YourComponent>

export default meta

type Story = StoryObj<typeof meta>

export const BasicUsage: Story = {
	// Story implementation
}
```

## File Organization

### Naming and Placement

- **Placement**: Co-locate story files with their source components
- **Extension**: Use `.stories.tsx` extension
- **Naming**: Follow `source_name.stories.tsx` pattern
- **Prop-specific stories**: Use `source_name.the_prop.stories.tsx` for testing specific props

### Story Naming Conventions

- **Default story**: Name it `BasicUsage`
- **Descriptive names**: Use names like `WithError`, `Loading`, etc.
- **Prop-specific names**: Use the `name` property for specific prop values:

```ts
export const Red100: Story = {
	name: 'red-100'
}
```

## Import Guidelines

### Import Patterns

1. **Main package exports**: Import components and utilities from main package exports (e.g., `../index.js`)
2. **Internal types**: Import Storybook types from `#repobuddy/storybook/internal`
3. **File extensions**: Always include `.js` extensions in import paths

```ts
// ‚úÖ Good: Import from main export
import { ShowHtml, defineDocsParam } from '../index.js'

// ‚úÖ Good: Import types from internal
import type { Meta, StoryObj } from '#repobuddy/storybook/internal'

// ‚ùå Bad: Direct component import (unless testing specific implementation)
import { ShowHtml } from './show_html.js'
```

## Story Implementation

### Property Order

Follow this consistent order for story properties:

```tsx
export const SomeStory: Story = {
	name: 'descriptive-name',
	tags: ['tag1', 'tag2'],
	parameters: { /* story parameters */ },
	args: { /* default args */ },
	loaders: [ /* data loaders */ ],
	decorators: [ /* story decorators */ ],
	render: (args, context) => { /* custom render function */ },
	play: async ({ canvas, step }) => { /* interaction testing */ },
	experimental_afterEach: () => { /* cleanup */ }
}
```

### Render Function Best Practices

Use the `render` function to emphasize the testing subject:

```tsx
// ‚úÖ Good: Extract reusable components for clarity
export const OnChange: Story = {
	render() {
		const [logs, setLogs] = useState<string[]>([])

		return (
			<div>
				<RadioGroup onChange={(value) => {
					setLogs(logs => [...logs, `selection changed: ${value}`])
				}}>
					<Radio value="apple">Apple</Radio>
					<Radio value="banana">Banana</Radio>
				</RadioGroup>
				<LogPanel logs={logs} />
			</div>
		)
	}
}

// ‚ùå Bad: Inline styling creates noise
export const OnChange: Story = {
	render() {
		const [logs, setLogs] = useState<string[]>([])

		return (
			<div>
				<RadioGroup onChange={value => {
					setLogs(logs => [...logs, `selection changed: ${value}`])
				}}>
					<Radio value="apple">Apple</Radio>
					<Radio value="banana">Banana</Radio>
				</RadioGroup>
				<div style={{ backgroundColor: '#f5f5f5', padding: '1rem' }}>
					<h4>Log Panel</h4>
					{logs.map((entry) => (
						<pre>{entry}</pre>
					))}
				</div>
			</div>
		)
	}
}
```

## Tagging Guidelines

Use tags to categorize and organize your stories:

### Standard Tags

- `['autodocs']` - Generate automatic documentation
- `['new']` - Recently added components or features
- `['beta']` - Unstable or experimental features
- `['deprecated']` - Components that should be avoided
- `['internal']` - Hide from production builds
- `['version:X.Y']` - Version when feature became available

### Testing Tags

- `['unit']` - Unit test stories
- `['integration']` - Integration test stories
- `['snapshot']` - Snapshot test stories
- `['keyboard']` - Keyboard interaction stories

### Development Tags

- `['todo']` - Stories that need work
- `['code-only']` - Components without design
- `['outdated']` - Components with pending design updates

## Documentation and Testing

### Documentation Patterns

Use `defineDocsParam` for component and story documentation:

```ts
import { defineDocsParam } from '@repobuddy/storybook'

export const SomeStory: Story = {
	parameters: defineDocsParam({
		description: {
			story: 'Additional message goes here'
		}
	})
}
```

### Interaction Testing

Use the `play` function to interact and validate behavior:

```ts
export const InteractiveStory: Story = {
	play: async ({ canvas, step }) => {
		const button = canvas.getByRole('button')

		await step('click button', async () => {
			await userEvent.click(button)
		})

		await expect(button).toHaveTextContent('Clicked!')
	}
}
```

## Advanced Patterns

### Using Loaders

```ts
export const WithData: Story = {
	loaders: [
		() => ({
			api: { getCurrentStoryData: () => ({ parameters: {} }) },
			addons: { getConfig: () => ({}) }
		})
	],
	render: (_, { loaded: { api, addons } }) => (
		<Component api={api} addons={addons} />
	)
}
```

### Using Decorators

```ts
export const WithTheme: Story = {
	decorators: [
		(Story) => (
			<ThemeProvider theme={lightTheme}>
				<Story />
			</ThemeProvider>
		)
	],
	render: () => <Component />
}
```

## Complete Example

```tsx
import type { Meta, StoryObj } from '#repobuddy/storybook/internal'
import { defineDocsParam } from '../index.js'
import { ShowHtml } from './show_html.js'

const meta = {
	title: 'components/ShowHtml',
	tags: ['new', 'version:1.0', 'autodocs'],
	component: ShowHtml,
	parameters: defineDocsParam({
		description: {
			component: 'ShowHtml displays the HTML of a subject using htmlfy internally.'
		}
	}),
	argTypes: {
		config: {
			control: { type: 'object' }
		}
	}
} satisfies Meta<typeof ShowHtml>

export default meta

type Story = StoryObj<typeof meta>

export const BasicUsage: Story = {
	parameters: defineDocsParam({
		description: {
			story: 'The selector prop defaults to [data-testid="subject"]'
		}
	}),
	render: () => (
		<div className="flex flex-col gap-4">
			<div data-testid="subject">
				<button type="button" className="bg-sky-500 text-white rounded p-2">
					This is a button
				</button>
			</div>
			<ShowHtml />
		</div>
	)
}

export const NoSubjectFound: Story = {
	render: () => <ShowHtml selector="not-exist" />
}
```

## Quality Checklist

Before submitting a story, ensure:

- [ ] Story file uses `.stories.tsx` extension
- [ ] Story is co-located with source component
- [ ] Proper import patterns (main exports for components, internal for types)
- [ ] File extensions included in import paths
- [ ] Story follows CSF format with TypeScript
- [ ] Meta configuration includes appropriate tags
- [ ] Story properties follow consistent order
- [ ] Render functions emphasize testing subject
- [ ] Appropriate tags used for organization
- [ ] Documentation added using `defineDocsParam`
- [ ] Interactive testing included where relevant
- [ ] Edge cases and error states covered

## Common Issues

### Import Issues
- **Missing file extensions**: Always include `.js` extensions in import paths
- **Wrong import location**: Use main exports (`../index.js`) for components, internal for types

### Story Structure Issues
- **Missing TypeScript types**: Use `Meta<typeof Component>` and `StoryObj<typeof meta>`
- **Inconsistent property order**: Follow the defined property order in this guide

### Documentation Issues
- **Missing descriptions**: Use `defineDocsParam` for component and story documentation
- **No interaction testing**: Add `play` functions for behavior validation

## Integration with Other Rules

This rule works in conjunction with:

- [React Component Specification](mdc:.cursor/rules/commands/react_component_spec.mdc) - For component development standards
- [TypeScript Patterns](mdc:.cursor/rules/guidelines/typescript_patterns.mdc) - For TypeScript best practices
- [Naming Conventions](mdc:.cursor/rules/guidelines/naming_conventions.mdc) - For file naming consistency
- [Testing Patterns](mdc:.cursor/rules/guidelines/testing_patterns.mdc) - For testing strategies

Remember to follow these guidelines when creating new Storybook stories.

When you use this rule file, let me know this rule file is being used in the chat by mentioning the rule filename.
