---
description: Apply when writing, reviewing, or refactoring TypeScript code to ensure consistent typing patterns, proper import/export syntax, React component structure, and type-safe development practices. Use for all TypeScript/React development, code reviews, and when establishing new code patterns.
globs:
alwaysApply: false
---
# TypeScript Patterns and Best Practices

This repository uses TypeScript extensively with strict settings. Follow these patterns for consistent and type-safe code.

## Type Definitions

### Component Props

```ts
// Use interfaces for component props
interface ComponentNameProps {
	// Required props
	title: string
	// Optional props with explicit undefined
	variant?: 'primary' | 'secondary' | undefined
	// Event handlers with explicit undefined
	onClick?: (() => void) | undefined
	// Complex types
	data: Array<{ id: string; name: string }>
}

// Export interfaces for reuse
export type { ComponentNameProps }
```

### Generic Types

```ts
// Use generics for reusable components
interface ListProps<T> {
	items: T[]
	renderItem: (item: T, index: number) => React.ReactNode
	keyExtractor: (item: T) => string
}

// Constrain generics when needed
interface ApiResponse<T extends Record<string, unknown>> {
	data: T
	status: 'success' | 'error'
	message?: string | undefined
}
```

### Utility Types

```ts
// Use built-in utility types
type OptionalProps<T> = Partial<T>
type RequiredProps<T> = Required<T>
type PickProps<T, K extends keyof T> = Pick<T, K>
type OmitProps<T, K extends keyof T> = Omit<T, K>

// Custom utility types with explicit undefined
type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
type DeepPartial<T> = {
	[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> | undefined : T[P] | undefined
}
```

## Import/Export Patterns

### Verbatim Module Syntax

The project uses `verbatimModuleSyntax: true` in the TypeScript configuration, which enforces explicit import/export syntax. This setting requires:

- **File extensions**: Always include file extensions in import paths
- **Explicit imports**: Use `import type` for type-only imports
- **No barrel exports**: Import directly from source files, not from index files

**Why this matters:**
- Ensures consistent module resolution across different bundlers
- Prevents accidental runtime imports of type-only modules
- Improves tree-shaking and bundle optimization
- Enforces explicit dependency declarations

### Named Exports

```ts
// Prefer named exports for better tree-shaking
export function ComponentName() {
	/* ... */
}
export type { ComponentNameProps }
export const CONSTANT_VALUE = 'value'

// Use index files for clean imports
// index.ts
export { ComponentName } from './component_name.js'
export type { ComponentNameProps } from './component_name.js'
```

### Import Organization

```ts
// All imports except CSS (alphabetical)
import type { Meta, StoryObj } from '@storybook/react'
import { ComponentName } from '@repobuddy/storybook'
import type { ComponentProps } from '@repobuddy/storybook'
import React from 'react'
import { vi } from 'vitest'
import type { ParentType } from '../../types/parent.js'
import { helper } from '../utils/helper.js'
import type { LocalType } from './types.js'

// CSS imports (alphabetical)
import './component_name.css'
```

### Import Guidelines

```ts
// ✅ Correct: Direct import with extension
import { ShowHtml } from './components/show_html.js'

// ✅ Correct: Type-only import
import type { ShowHtmlProps } from './components/show_html.js'

// ❌ Wrong: Missing file extension
import { ShowHtml } from './components/show_html'

// ❌ Wrong: Barrel export import
import { ShowHtml } from './components'

// ❌ Wrong: Mixed type and value import
import { ShowHtml, type ShowHtmlProps } from './components/show_html.js'
```

## React Patterns

### Function Components

```tsx
// Use function components with proper typing
export function ComponentName({ title, onClick }: ComponentNameProps) {
	return (
		<button onClick={onClick}>
			{title}
		</button>
	)
}

// Use React.FC sparingly, prefer explicit prop typing
// Only use when you need children prop
interface WithChildrenProps {
	children: React.ReactNode
}

export const WithChildren: React.FC<WithChildrenProps> = ({ children }) => {
	return <div>{children}</div>
}
```

### Hooks

```ts
// Type custom hooks properly
function useCustomHook<T>(initialValue: T) {
	const [value, setValue] = useState<T>(initialValue)

	const updateValue = useCallback((newValue: T) => {
		setValue(newValue)
	}, [])

	return { value, updateValue }
}

// Type hook return values
interface UseApiReturn<T> {
	data: T | null
	loading: boolean
	error: Error | null
	refetch: () => Promise<void>
}

// Implementation example
function useApi<T>(url: string): UseApiReturn<T> {
	const [data, setData] = useState<T | null>(null)
	const [loading, setLoading] = useState(true)
	const [error, setError] = useState<Error | null>(null)

	const fetchData = useCallback(async () => {
		try {
			setLoading(true)
			const response = await fetch(url)
			const result = await response.json()
			setData(result)
		} catch (err) {
			setError(err as Error)
		} finally {
			setLoading(false)
		}
	}, [url])

	useEffect(() => {
		fetchData()
	}, [fetchData])

	return { data, loading, error, refetch: fetchData }
}
```

### Event Handlers

```ts
// Type event handlers properly
const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
	event.preventDefault()
	// handler logic
}

const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
	const value = event.target.value
	// handler logic
}

// For form events
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
	event.preventDefault()
	// form submission logic
}

// Keyboard events
const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {
	if (event.key === 'Enter') {
		// handle enter key
	}
}

// Drag events
const handleDragStart = (event: React.DragEvent<HTMLDivElement>) => {
	event.dataTransfer.setData('text/plain', event.currentTarget.id)
}

// Form events with proper typing
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
	event.preventDefault()
	const formData = new FormData(event.currentTarget)
	// form submission logic
}

// Change events for different input types
const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
	const { name, value, type, checked } = event.target
	// handle different input types
}

const handleSelectChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
	const { value } = event.target
	// handle select change
}
```

## Storybook Integration

### Meta Types

```ts
// Use the extended Meta type from the repository
import type { Meta, StoryObj } from '#repobuddy/storybook/internal.js'

const meta = {
	title: 'components/ComponentName',
	component: ComponentName,
	tags: ['autodocs', 'new'],
	parameters: {
		layout: 'centered'
	}
} satisfies Meta<typeof ComponentName>

export default meta
type Story = StoryObj<typeof meta>
```

### Story Types

```ts
// Type stories with proper args
export const Default: Story = {
	args: {
		title: 'Default Title',
		variant: 'primary'
	}
}

// Type complex story configurations
export const WithComplexData: Story = {
	args: {
		data: [
			{ id: '1', name: 'Item 1' },
			{ id: '2', name: 'Item 2' }
		]
	},
	play: async ({ canvasElement }) => {
		// Type-safe play function
		const canvas = within(canvasElement)
		// interaction logic
	}
}
```

## Error Handling

### Result Types

```ts
// Use Result pattern for error handling
type Result<T, E = Error> =
	| { success: true; data: T }
	| { success: false; error: E }

// Usage
function fetchData(): Promise<Result<UserData>> {
	try {
		const data = await api.getUser()
		return { success: true, data }
	} catch (error) {
		return { success: false, error: error as Error }
	}
}
```

### Optional Chaining

```ts
// Use optional chaining for safe property access
const userName = user?.profile?.name ?? 'Anonymous'
const firstItem = items?.[0]?.title

// For function calls
const result = api?.fetchData?.() ?? null
```

## TypeScript Configuration

### Key Settings

The project uses strict TypeScript settings defined in [libs/storybook/tsconfig.json](mdc:libs/storybook/tsconfig.json):

- **strict**: `true` - Enables all strict type checking options
- **verbatimModuleSyntax**: `true` - **Critical**: Requires file extensions and explicit imports
- **explicitOptionalType**: `true` - **Critical**: Requires explicit `| undefined` for optional types
- **isolatedModules**: `true` - Ensures files can be safely transpiled
- **target**: `ES2020` - Modern JavaScript features
- **moduleResolution**: `bundler` - Optimized for Vite

### Why These Settings Matter

- **verbatimModuleSyntax**: Prevents accidental runtime imports of type-only modules
- **explicitOptionalType**: Makes optional types explicit with `| undefined`, improving type clarity
- **strict**: Catches type errors early and enforces best practices
- **isolatedModules**: Ensures compatibility with bundlers and build tools

### Explicit Optional Types

With `explicitOptionalType: true`, TypeScript requires explicit `| undefined` for optional properties:

```ts
// ✅ Correct: Explicit undefined for optional properties
interface User {
	id: string
	name: string
	email?: string | undefined
	profile?: UserProfile | undefined
}

// ✅ Correct: Function parameters with explicit undefined
function updateUser(
	id: string,
	name?: string | undefined,
	email?: string | undefined
) {
	// Implementation
}

// ✅ Correct: Return types with explicit undefined
function findUser(id: string): User | undefined {
	// Implementation
}

// ❌ Wrong: Implicit optional types (will cause errors with explicitOptionalType)
interface User {
	id: string
	name: string
	email?: string // Error: must be string | undefined
}

// ❌ Wrong: Function parameters without explicit undefined
function updateUser(id: string, name?: string) {
	// Error: must be string | undefined
}
```

### Vite Config

```ts
// Type Vite configuration
import type { UserConfig } from 'vite'
import { defineConfig } from 'vite'

export default defineConfig({
	// typed configuration
} satisfies UserConfig)
```

## Common Pitfalls and Solutions

### Avoid Type Assertions

```typescript
// ❌ Bad: Unsafe type assertion
const data = response as UserData

// ✅ Good: Type guard or proper typing
function isUserData(obj: unknown): obj is UserData {
	return obj && typeof obj === 'object' && 'id' in obj
}

const data = isUserData(response) ? response : null
```

### Proper Generic Constraints

```typescript
// ❌ Bad: Too permissive
function processData<T>(data: T) {
	return data.toString() // Error: T might not have toString
}

// ✅ Good: Proper constraints
function processData<T extends { toString(): string }>(data: T) {
	return data.toString()
}
```

### Handling Optional Properties

```typescript
// ❌ Bad: Unsafe property access
const name = user.profile.name // Error if profile is undefined

// ✅ Good: Safe property access with explicit undefined handling
const name = user.profile?.name ?? 'Anonymous'
const profile = user.profile || null
```

### Proper Array Type Definitions

```typescript
// ❌ Bad: Implicit any[]
const items = [] // Type is any[]

// ✅ Good: Explicit typing
const items: string[] = []
const items = [] as string[]
const items: Array<string> = []
```

### Explicit Optional Types in Practice

```typescript
// ✅ Good: Explicit undefined for all optional properties
interface ComponentProps {
	title: string
	subtitle?: string | undefined
	onClick?: (() => void) | undefined
	children?: React.ReactNode | undefined
	data?: Array<{ id: string; name: string }> | undefined
}

// ✅ Good: Function signatures with explicit undefined
function handleUserAction(
	userId: string,
	action?: 'edit' | 'delete' | undefined,
	callback?: (() => void) | undefined
): Promise<void> {
	// Implementation
}

// ✅ Good: Return types with explicit undefined
function getUserById(id: string): User | undefined {
	// Implementation
}

// ✅ Good: Union types with explicit undefined
type Status = 'loading' | 'success' | 'error' | undefined
type ApiResponse<T> = {
	data: T
	status: Status
	message?: string | undefined
}
```

## Testing with TypeScript

### Mock Types

```typescript
// Type your mocks properly with explicit undefined
const mockApi = {
	fetchUser: vi.fn<[string], Promise<User | undefined>>(),
	updateUser: vi.fn<[string, Partial<User> | undefined], Promise<User>>()
} as const

// Type test utilities
interface TestUtils {
	render: (component: React.ReactElement) => RenderResult
	waitFor: (callback: () => void) => Promise<void>
}

const createTestUtils = (): TestUtils => ({
	render: (component) => render(component),
	waitFor: (callback) => waitFor(callback)
})
```

### Type-Safe Test Data

```typescript
// Create type-safe test data with explicit undefined
const createMockUser = (overrides?: Partial<User> | undefined): User => ({
	id: 'test-id',
	name: 'Test User',
	email: 'test@example.com',
	...overrides
})

// Use in tests
const user = createMockUser({ name: 'Custom Name' })
```

## Type Safety Patterns

```typescript
// Use proper type annotations with explicit undefined
interface User {
	id: string
	name: string
	email?: string | undefined
}

// Generic types for reusable components
interface ListProps<T> {
	items: T[]
	renderItem: (item: T) => React.ReactNode
	onItemClick?: ((item: T) => void) | undefined
}

export function List<T>({ items, renderItem, onItemClick }: ListProps<T>) {
	return (
		<ul>
			{items.map((item, index) => (
				<li key={index} onClick={() => onItemClick?.(item)}>
					{renderItem(item)}
				</li>
			))}
		</ul>
	)
}

// Utility types for common patterns with explicit undefined
type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
type Required<T, K extends keyof T> = T & Required<Pick<T, K>>
```

## Documentation

### JSDoc Comments

```typescript
/**
 * Fetches user data from the API
 * @param userId - The unique identifier of the user
 * @param options - Optional configuration for the request
 * @returns Promise resolving to user data or undefined
 * @throws {Error} When the API request fails
 */
async function fetchUserData(
	userId: string,
	options?: RequestOptions | undefined
): Promise<UserData | undefined> {
	// Implementation
}

/**
 * User profile component that displays user information
 * @param props - Component props
 * @param props.user - User data to display
 * @param props.onEdit - Callback when edit button is clicked
 */
export function UserProfile({ user, onEdit }: UserProfileProps) {
	// Implementation
}
```

### Inline Comments

```typescript
// Use comments to explain "why", not "what"
// This timeout prevents rapid-fire API calls during user typing
const DEBOUNCE_TIMEOUT = 300

// Bad: This sets the state to true
// Good: Enable loading state while API call is in progress
setLoading(true)

// Use TODO comments for future improvements
// TODO: Add error boundary for better error handling
// TODO: Optimize re-renders with React.memo
```

## Best Practices

### Type Safety

1. **Avoid `any`**: Use proper types or `unknown` when type is truly unknown
2. **Use `unknown` over `any`**: More type-safe alternative
3. **Prefer interfaces over types**: Better for object shapes
4. **Use const assertions**: `as const` for literal types
5. **Leverage discriminated unions**: For complex state management
6. **Use explicit undefined**: Always include `| undefined` for optional types

### Performance

1. **Use `React.memo`**: For expensive components
2. **Proper dependency arrays**: In useEffect and useCallback
3. **Lazy loading**: For code splitting
4. **Type-only imports**: Reduce bundle size

### Code Organization

1. **Co-locate types**: Keep types close to their usage
2. **Shared types**: Put common types in dedicated files
3. **Barrel exports**: Use index files for clean imports
4. **Consistent naming**: Use PascalCase for types, camelCase for values

### Testing

1. **Type test utilities**: Use TypeScript for compile-time testing
2. **Mock types**: Properly type mocks and test utilities
3. **Story types**: Ensure Storybook stories are properly typed

When you use this rule file, let me know this rule file is being used in the chat by mentioning the rule filename.
