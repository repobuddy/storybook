---
description:
globs:
alwaysApply: false
---
# TypeScript Patterns and Best Practices

This repository uses TypeScript extensively with strict settings. Follow these patterns for consistent and type-safe code.

## Type Definitions

### Component Props

```ts
// Use interfaces for component props
interface ComponentNameProps {
	// Required props
	title: string
	// Optional props with default values
	variant?: 'primary' | 'secondary'
	// Event handlers
	onClick?: () => void
	// Complex types
	data: Array<{ id: string; name: string }>
}

// Export interfaces for reuse
export type { ComponentNameProps }
```

### Generic Types

```ts
// Use generics for reusable components
interface ListProps<T> {
	items: T[]
	renderItem: (item: T, index: number) => React.ReactNode
	keyExtractor: (item: T) => string
}

// Constrain generics when needed
interface ApiResponse<T extends Record<string, unknown>> {
	data: T
	status: 'success' | 'error'
	message?: string
}
```

### Utility Types

```ts
// Use built-in utility types
type OptionalProps<T> = Partial<T>
type RequiredProps<T> = Required<T>
type PickProps<T, K extends keyof T> = Pick<T, K>
type OmitProps<T, K extends keyof T> = Omit<T, K>

// Custom utility types
type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
type DeepPartial<T> = {
	[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}
```

## Import/Export Patterns

### Named Exports

```ts
// Prefer named exports for better tree-shaking
export function ComponentName() {
	/* ... */
}
export type { ComponentNameProps }
export const CONSTANT_VALUE = 'value'

// Use index files for clean imports
// index.ts
export { ComponentName } from './component_name.js'
export type { ComponentNameProps } from './component_name.js'
```

### Import Organization

```ts
// External dependencies first
import React from 'react'
import type { Meta, StoryObj } from '@storybook/react'

// Internal workspace dependencies
import { ComponentName } from '@repobuddy/storybook'

// Relative imports last
import './component_name.css'
import type { LocalType } from './types.js'
```

### Type-Only Imports

```ts
// Use type-only imports for types
import type { ComponentProps } from 'react'
import type { StoryObj } from '@storybook/react'

// Separate type and value imports
import { useState } from 'react'
import type { Dispatch, SetStateAction } from 'react'
```

## React Patterns

### Function Components

```tsx
// Use function components with proper typing
export function ComponentName({ title, onClick }: ComponentNameProps) {
	return (
		<button onClick={onClick}>
			{title}
		</button>
	)
}

// Use React.FC sparingly, prefer explicit prop typing
// Only use when you need children prop
interface WithChildrenProps {
	children: React.ReactNode
}

export const WithChildren: React.FC<WithChildrenProps> = ({ children }) => {
	return <div>{children}</div>
}
```

### Hooks

```ts
// Type custom hooks properly
function useCustomHook<T>(initialValue: T) {
	const [value, setValue] = useState<T>(initialValue)

	const updateValue = useCallback((newValue: T) => {
		setValue(newValue)
	}, [])

	return { value, updateValue }
}

// Type hook return values
interface UseApiReturn<T> {
	data: T | null
	loading: boolean
	error: Error | null
	refetch: () => Promise<void>
}
```

### Event Handlers

```ts
// Type event handlers properly
const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
	event.preventDefault()
	// handler logic
}

const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
	const value = event.target.value
	// handler logic
}

// For form events
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
	event.preventDefault()
	// form submission logic
}
```

## Storybook Integration

### Meta Types

```ts
// Use the extended Meta type from the repository
import type { Meta, StoryObj } from '#repobuddy/storybook/internal.js'

const meta = {
	title: 'components/ComponentName',
	component: ComponentName,
	tags: ['autodocs', 'new'],
	parameters: {
		layout: 'centered'
	}
} satisfies Meta<typeof ComponentName>

export default meta
type Story = StoryObj<typeof meta>
```

### Story Types

```ts
// Type stories with proper args
export const Default: Story = {
	args: {
		title: 'Default Title',
		variant: 'primary'
	}
}

// Type complex story configurations
export const WithComplexData: Story = {
	args: {
		data: [
			{ id: '1', name: 'Item 1' },
			{ id: '2', name: 'Item 2' }
		]
	},
	play: async ({ canvasElement }) => {
		// Type-safe play function
		const canvas = within(canvasElement)
		// interaction logic
	}
}
```

## Error Handling

### Result Types

```ts
// Use Result pattern for error handling
type Result<T, E = Error> =
	| { success: true; data: T }
	| { success: false; error: E }

// Usage
function fetchData(): Promise<Result<UserData>> {
	try {
		const data = await api.getUser()
		return { success: true, data }
	} catch (error) {
		return { success: false, error: error as Error }
	}
}
```

### Optional Chaining

```ts
// Use optional chaining for safe property access
const userName = user?.profile?.name ?? 'Anonymous'
const firstItem = items?.[0]?.title

// For function calls
const result = api?.fetchData?.() ?? null
```

## Configuration Files

### TypeScript Config

The main TypeScript configuration is defined in [libs/storybook/tsconfig.json](mdc:libs/storybook/tsconfig.json) with strict settings:

```jsonc
{
	"compilerOptions": {
		"composite": true,
		"isolatedModules": true,
		"jsx": "react",
		"lib": ["ESNext", "DOM.Iterable", "DOM"],
		"module": "ESNext",
		"moduleResolution": "bundler",
		"outDir": "esm",
		"skipLibCheck": true,
		"strict": true,
		"target": "ES2020",
		"verbatimModuleSyntax": true
	},
	"include": ["src", "types", ".storybook"]
}
```

Key configuration options:

- **strict**: `true` - Enables all strict type checking options
- **isolatedModules**: `true` - Ensures each file can be safely transpiled
- **verbatimModuleSyntax**: `true` - Enforces explicit import/export syntax
- **target**: `ES2020` - Modern JavaScript features
- **moduleResolution**: `bundler` - Optimized for bundlers like Vite

### Vite Config

```ts
// Type Vite configuration
import type { UserConfig } from 'vite'
import { defineConfig } from 'vite'

export default defineConfig({
	// typed configuration
} satisfies UserConfig)
```

## Best Practices

### Type Safety

1. **Avoid `any`**: Use proper types or `unknown` when type is truly unknown
2. **Use `unknown` over `any`**: More type-safe alternative
3. **Prefer interfaces over types**: Better for object shapes
4. **Use const assertions**: `as const` for literal types
5. **Leverage discriminated unions**: For complex state management

### Performance

1. **Use `React.memo`**: For expensive components
2. **Proper dependency arrays**: In useEffect and useCallback
3. **Lazy loading**: For code splitting
4. **Type-only imports**: Reduce bundle size

### Code Organization

1. **Co-locate types**: Keep types close to their usage
2. **Shared types**: Put common types in dedicated files
3. **Barrel exports**: Use index files for clean imports
4. **Consistent naming**: Use PascalCase for types, camelCase for values

### Testing

1. **Type test utilities**: Use TypeScript for compile-time testing
2. **Mock types**: Properly type mocks and test utilities
3. **Story types**: Ensure Storybook stories are properly typed

When you use this rule file, let me know this rule file is being used in the chat by mentioning the rule filename.
