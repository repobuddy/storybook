---
description:
globs:
alwaysApply: false
---
---
description: Apply when writing unit tests, integration tests, Storybook stories, or test configurations to ensure consistent testing patterns and coverage strategies
globs:
  - "**/*.{test,spec}.{ts,tsx}"
  - "**/*.stories.{ts,tsx}"
# Testing Patterns and Best Practices

This repository uses Vitest for unit testing and Storybook for component testing. Follow these patterns for comprehensive test coverage.

## Quick Decision Tree

**Writing a component test?** → [Component Testing Patterns](mdc:#component-testing-patterns)
**Writing a Storybook story?** → [Storybook Testing Patterns](mdc:#storybook-testing-patterns)
**Writing a utility function test?** → [Utility Function Testing](mdc:#utility-function-testing)
**Setting up test configuration?** → [Vitest Configuration](mdc:#vitest-configuration)
**Need test utilities?** → [Test Utilities](mdc:#test-utilities)

## File Organization Standards

### Test File Structure

```
src/
├── components/
│   ├── component_name/
│   │   ├── component_name.tsx          # Component implementation
│   │   ├── component_name.stories.tsx  # Storybook stories
│   │   └── component_name.test.tsx     # Unit tests
│   └── utils/
│       ├── utils.ts                    # Utility functions
│       └── utils.test.ts               # Utility tests
```

### Naming Conventions

- **Test files**: `component_name.test.tsx` or `component_name.spec.tsx`
- **Story files**: `component_name.stories.tsx`
- **Test utilities**: `test_utils.tsx` or `testing_helpers.ts`
- **Mock files**: `mocks.ts` or `test_mocks.ts`

## Component Testing Patterns

### Standard Component Test Template

```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import userEvent from '@testing-library/user-event'
import { ComponentName } from './component_name.js'

describe('ComponentName', () => {
  it('renders with default props', () => {
    render(<ComponentName title="Test Title" />)
    expect(screen.getByText('Test Title')).toBeInTheDocument()
  })

  it('handles click events', async () => {
    const handleClick = vi.fn()
    render(<ComponentName onClick={handleClick} />)

    await userEvent.click(screen.getByRole('button'))
    expect(handleClick).toHaveBeenCalledOnce()
  })

  it('applies variant styles correctly', () => {
    render(<ComponentName variant="primary" />)
    const element = screen.getByRole('button')
    expect(element).toHaveClass('variant-primary')
  })
})
```

### Common Test Patterns

| Test Type | Pattern | Example |
|---|---|---|
| **Rendering** | Test component displays correctly | `expect(screen.getByText('text')).toBeInTheDocument()` |
| **User Interaction** | Test click, input, navigation | `await userEvent.click(button)` |
| **Props Validation** | Test prop changes affect component | `render(<Component prop="value" />)` |
| **Accessibility** | Test ARIA attributes and keyboard nav | `expect(button).toHaveAccessibleName('text')` |
| **Event Handling** | Test event callbacks | `expect(handleClick).toHaveBeenCalledWith('value')` |
| **Conditional Rendering** | Test conditional UI elements | `expect(screen.queryByText('text')).not.toBeInTheDocument()` |

### Import Patterns

```ts
// Always include these imports for component tests
import { render, screen } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import userEvent from '@testing-library/user-event'

// Component under test
import { ComponentName } from './component_name.js'

// Test utilities (if needed)
import { customRender } from './test_utils.js'
```

## Hook Testing Patterns

### Standard Hook Test Template

```tsx
import { renderHook, act } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { useCustomHook } from './use_custom_hook.js'

describe('useCustomHook', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCustomHook('initial'))
    expect(result.current.value).toBe('initial')
  })

  it('updates value when called', () => {
    const { result } = renderHook(() => useCustomHook('initial'))

    act(() => {
      result.current.updateValue('updated')
    })

    expect(result.current.value).toBe('updated')
  })
})
```

## Utility Function Testing

### Standard Utility Test Template

```ts
import { describe, it, expect } from 'vitest'
import { formatDate, validateEmail } from './utils.js'

describe('formatDate', () => {
  it('formats date correctly', () => {
    const date = new Date('2023-01-15')
    expect(formatDate(date)).toBe('Jan 15, 2023')
  })

  it('handles invalid dates', () => {
    expect(formatDate(null)).toBe('Invalid Date')
  })
})

describe('validateEmail', () => {
  it('validates correct email formats', () => {
    expect(validateEmail('test@example.com')).toBe(true)
    expect(validateEmail('user.name+tag@domain.co.uk')).toBe(true)
  })

  it('rejects invalid email formats', () => {
    expect(validateEmail('invalid-email')).toBe(false)
    expect(validateEmail('test@')).toBe(false)
    expect(validateEmail('@domain.com')).toBe(false)
  })
})
```

## Storybook Testing Patterns

### Standard Story Template

```tsx
import type { Meta, StoryObj } from '#repobuddy/storybook/internal'
import { expect, userEvent } from 'storybook/test'
import { ComponentName } from './component_name.js'

const meta = {
  title: 'components/ComponentName',
  component: ComponentName,
  tags: ['autodocs', 'test'],
  parameters: {
    layout: 'centered'
  }
} satisfies Meta<typeof ComponentName>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    title: 'Default Title'
  }
}

export const WithInteraction: Story = {
  args: {
    title: 'Interactive Title'
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)
    const button = canvas.getByRole('button')

    await userEvent.click(button)
    await expect(canvas.getByText('Clicked!')).toBeInTheDocument()
  }
}
```

### Visual Regression Testing

```tsx
export const AllVariants: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '1rem' }}>
      <ComponentName variant="primary" title="Primary" />
      <ComponentName variant="secondary" title="Secondary" />
      <ComponentName variant="danger" title="Danger" />
    </div>
  ),
  parameters: {
    chromatic: { disableSnapshot: false }
  }
}
```

### Accessibility Testing

```tsx
export const AccessibilityTest: Story = {
  args: {
    title: 'Accessible Button'
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Test keyboard navigation
    const button = canvas.getByRole('button')
    button.focus()
    expect(button).toHaveFocus()

    // Test screen reader text
    expect(button).toHaveAccessibleName('Accessible Button')
  },
  parameters: {
    a11y: {
      config: {
        rules: [
          { id: 'button-name', enabled: true }
        ]
      }
    }
  }
}
```

## Vitest Configuration

### Standard Test Setup

```ts
// vitest.config.ts
import { defineProject } from 'vitest/config'
import { browserTestPreset } from '@repobuddy/vitest/config'

export default defineProject({
  plugins: [browserTestPreset()],
  test: {
    name: 'package-name',
    setupFiles: ['.storybook/vitest.setup.ts']
  }
})
```

### Coverage Configuration

```ts
// vitest.config.ts
export default defineProject({
  test: {
    coverage: {
      include: ['src/**/*.{ts,tsx}'],
      exclude: [
        '**/*.stories.{ts,tsx}',
        '**/*.test.{ts,tsx}',
        '**/index.ts'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  }
})
```

## Test Utilities

### Custom Render Function

```tsx
// test_utils.tsx
import { render, type RenderOptions } from 'vitest-browser-react'
import { themes, ThemeProvider } from 'storybook/theming'

interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  theme?: 'light' | 'dark'
}

export function customRender(
  ui: React.ReactElement,
  options: CustomRenderOptions = {}
) {
  const { theme = 'light', ...renderOptions } = options

  const Wrapper = ({ children }: { children: React.ReactNode }) => (
    <ThemeProvider theme={themes[theme]}>
      {children}
    </ThemeProvider>
  )

  return render(ui, { wrapper: Wrapper, ...renderOptions })
}
```

### Mock Utilities

```ts
// mocks.ts
import { vi } from 'vitest'

export const mockApi = {
  fetchData: vi.fn(),
  postData: vi.fn()
}

export const mockLocalStorage = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn()
}

// Setup in test files
beforeEach(() => {
  vi.clearAllMocks()
  Object.defineProperty(window, 'localStorage', {
    value: mockLocalStorage,
    writable: true
  })
})
```

## Best Practices Checklist

### Test Organization

- [ ] Use **Arrange-Act-Assert** pattern
- [ ] Write **descriptive test names**
- [ ] Test **one thing per test**
- [ ] Use `beforeEach`/`afterEach` for setup/teardown
- [ ] Group related tests with `describe` blocks

### Test Data

- [ ] Use **factory functions** for test data
- [ ] Store **complex data in fixtures**
- [ ] Use **deterministic random data** for edge cases
- [ ] Use **realistic data** that matches production

### Performance

- [ ] Keep tests **fast and focused**
- [ ] Use **parallel execution** with Vitest
- [ ] **Mock external dependencies** and APIs
- [ ] **Clean up** after tests properly

### Maintenance

- [ ] Follow **DRY principle** - avoid test code duplication
- [ ] Create **reusable test utilities**
- [ ] Use **consistent patterns** across codebase
- [ ] **Document complex test scenarios**

### Storybook Integration

- [ ] Every component has **stories**
- [ ] Use **play functions** for interaction testing
- [ ] Include **visual regression testing**
- [ ] Add **accessibility testing** to stories

## Common Anti-Patterns to Avoid

### ❌ Don't Do This

```tsx
// ❌ Testing multiple things in one test
it('handles everything', () => {
  render(<Component />)
  expect(screen.getByText('text')).toBeInTheDocument()
  fireEvent.click(button)
  expect(handleClick).toHaveBeenCalled()
  expect(element).toHaveClass('class')
})

// ❌ Using fireEvent instead of userEvent
fireEvent.click(button)

// ❌ Testing implementation details
expect(component.state.value).toBe('test')

// ❌ Not cleaning up mocks
// Missing vi.clearAllMocks() in beforeEach
```

### ✅ Do This Instead

```tsx
// ✅ Testing one thing per test
it('renders with default props', () => {
  render(<Component />)
  expect(screen.getByText('text')).toBeInTheDocument()
})

it('handles click events', async () => {
  const handleClick = vi.fn()
  render(<Component onClick={handleClick} />)
  await userEvent.click(screen.getByRole('button'))
  expect(handleClick).toHaveBeenCalledOnce()
})

// ✅ Using userEvent for realistic interactions
await userEvent.click(button)

// ✅ Testing user-visible behavior
expect(screen.getByText('result')).toBeInTheDocument()

// ✅ Proper mock cleanup
beforeEach(() => {
  vi.clearAllMocks()
})
```

When you use this rule file, let me know this rule file is being used in the chat by mentioning the rule filename.
